name: Deploy Complete EKS Stack

on:
  workflow_dispatch:
    inputs:
      confirm_deploy:
        description: 'Type "DEPLOY" to confirm EKS stack deployment'
        required: true
        type: string
      deploy_k8s:
        description: 'Deploy Kubernetes/Helm resources (aws-auth, ns, ALB controller, Rancher)'
        required: false
        type: choice
        default: 'false'
        options:
        - 'false'
        - 'true'

jobs:
  validate:
    name: Validate Code
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0


    - name: Terraform Init (syntax check only)
      run: terraform init -backend=false

    - name: Terraform Format (auto-fix)
      run: terraform fmt -recursive

    - name: Terraform Validate
      run: terraform validate

    - name: Terraform Format Check
      run: terraform fmt -check -recursive

  deploy:
    name: Deploy to AWS Production
    runs-on: ubuntu-latest
    needs: validate
    environment: production
    permissions:
      id-token: write
      contents: read    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.ROLE_ARN }}
        role-session-name: GitHubActions-TerraformDeploy
        aws-region: us-east-1
        audience: sts.amazonaws.com

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0

    - name: Initialize Terraform
      run: |
        terraform init

    - name: Pre-create kubeconfig if deploying K8s
      if: ${{ github.event.inputs.deploy_k8s == 'true' }}
      run: |
        aws eks update-kubeconfig --region us-east-1 --name $(terraform output -raw cluster_name || echo rancher-eks-cluster) --kubeconfig /tmp/kubeconfig || true
        ls -l /tmp || true

    - name: Plan Terraform (EKS only)
      run: |
        terraform plan -refresh=false \
          -var-file=terraform.tfvars \
          -var 'deploy_k8s=false' \
          -var 'pipeline_deployer_role_arn=${{ secrets.ROLE_ARN }}' \
          -target=data.aws_eks_cluster.selected \
          -target=module.network \
          -target=module.backend.aws_iam_role.cluster \
          -target=module.backend.aws_iam_role_policy_attachment.cluster_AmazonEKSClusterPolicy \
          -target=module.backend.aws_eks_cluster.main \
          -target=module.backend.aws_iam_role.nodes \
          -target=module.backend.aws_iam_role_policy_attachment.nodes_AmazonEKSWorkerNodePolicy \
          -target=module.backend.aws_iam_role_policy_attachment.nodes_AmazonEKS_CNI_Policy \
          -target=module.backend.aws_iam_role_policy_attachment.nodes_AmazonEC2ContainerRegistryReadOnly \
          -target=module.backend.aws_security_group.node_group_sg \
          -target=module.backend.aws_eks_node_group.main \
          -target=module.backend.aws_iam_openid_connect_provider.eks \
          -target=module.backend.aws_iam_policy.aws_load_balancer_controller \
          -target=module.backend.aws_iam_role.aws_load_balancer_controller \
          -target=module.backend.aws_iam_role_policy_attachment.aws_load_balancer_controller \
          -out=tfplan

    - name: Apply Terraform (EKS only)
      run: |
        terraform apply -auto-approve tfplan

    - name: Wait for EKS to be ACTIVE
      run: |
        CLUSTER_NAME=$(terraform output -raw cluster_name)
        echo "Waiting for EKS cluster $CLUSTER_NAME to be ACTIVE..."
        for i in {1..40}; do
          STATUS=$(aws eks describe-cluster --name "$CLUSTER_NAME" --query 'cluster.status' --output text || echo "UNKNOWN")
          echo "Status: $STATUS"
          [ "$STATUS" = "ACTIVE" ] && exit 0
          sleep 15
        done
        echo "Cluster not ACTIVE in time" && exit 1

    - name: Plan Terraform (Bootstrap pipeline access)
      if: ${{ github.event.inputs.deploy_k8s == 'true' }}
      run: |
        terraform plan -refresh=false \
          -var-file=terraform.tfvars \
          -var 'create_pipeline_access=true' \
          -var 'pipeline_deployer_role_arn=${{ secrets.ROLE_ARN }}' \
          -target=data.aws_eks_cluster.selected \
          -target=module.backend.aws_eks_access_entry.pipeline \
          -target=module.backend.aws_eks_access_policy_association.pipeline \
          -out=tfplan_bootstrap

    - name: Apply Terraform (Bootstrap pipeline access)
      if: ${{ github.event.inputs.deploy_k8s == 'true' }}
      run: |
        terraform apply -auto-approve tfplan_bootstrap
        echo "Waiting RBAC propagation..."; sleep 20

    - name: Generate kubeconfig for providers
      if: ${{ github.event.inputs.deploy_k8s == 'true' }}
      run: |
        aws eks update-kubeconfig --region us-east-1 --name $(terraform output -raw cluster_name) --kubeconfig /tmp/kubeconfig
        test -f /tmp/kubeconfig && echo "kubeconfig ready"

    - name: Export KUBECONFIG env
      if: ${{ github.event.inputs.deploy_k8s == 'true' }}
      run: echo "KUBECONFIG=/tmp/kubeconfig" >> $GITHUB_ENV

    - name: Plan Terraform (aws-auth only)
      if: ${{ github.event.inputs.deploy_k8s == 'true' }}
      run: |
        echo "Skipping aws-auth (cluster uses API auth)"

    - name: Apply Terraform (aws-auth only)
      if: ${{ github.event.inputs.deploy_k8s == 'true' }}
      run: |
        echo "Skipping aws-auth apply"

    - name: Validate RBAC after bootstrap
      if: ${{ github.event.inputs.deploy_k8s == 'true' }}
      run: |
        for i in {1..20}; do
          CAN_NS=$(kubectl --kubeconfig /tmp/kubeconfig auth can-i create namespaces || echo no)
          CAN_CRD=$(kubectl --kubeconfig /tmp/kubeconfig auth can-i create customresourcedefinitions.apiextensions.k8s.io || echo no)
          echo "Attempt $i - namespaces: $CAN_NS, CRDs: $CAN_CRD"
          if [ "$CAN_NS" = "yes" ] && [ "$CAN_CRD" = "yes" ]; then echo "RBAC ready"; break; fi
          sleep 5
        done

    - name: Plan Terraform (K8s/Helm)
      if: ${{ github.event.inputs.deploy_k8s == 'true' }}
      run: |
        terraform plan -refresh=false -var-file=terraform.tfvars -var 'deploy_k8s=true' -var 'pipeline_deployer_role_arn=${{ secrets.ROLE_ARN }}' \
          -target=module.backend.kubernetes_namespace.cattle_system \
          -target=module.backend.helm_release.aws_load_balancer_controller \
          -target=module.backend.helm_release.rancher \
          -target=module.backend.kubernetes_ingress_v1.rancher_ingress \
          -out=tfplan_k8s

    - name: Apply Terraform (K8s/Helm)
      if: ${{ github.event.inputs.deploy_k8s == 'true' }}
      run: |
        terraform apply -auto-approve tfplan_k8s

    - name: Export Terraform Outputs
      run: |
        echo "Terraform Outputs:"
        terraform output

    - name: Complete Stack Summary
      run: |
        echo "ðŸš€ EKS STACK DEPLOYED!"
        echo "======================"
        echo "Environment: Production"
        echo "Cluster Name: $(terraform output -raw cluster_name)"
        echo "Cluster Endpoint: $(terraform output -raw cluster_endpoint)"
        echo "Region: us-east-1"
        echo ""
        echo "K8s/Helm applied: ${{ github.event.inputs.deploy_k8s || 'false' }}"

    - name: Debug assumed role
      run: |
        aws sts get-caller-identity
        echo "Expected ROLE ARN: ${{ secrets.ROLE_ARN }}"
